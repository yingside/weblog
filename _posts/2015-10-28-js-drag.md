---
layout: post
title: 通过实例学习javascript函数封装(一)--拖拽
tags:  [javascript,function]
categories: [javascript]
author: Yingside
excerpt: "很多初学者对于函数的封装相当的畏惧,往往都是至上而下直接将程序实现就行,这一系列文章主要是通过几个经常见到的实例来演示函数的封装,以及讲解一下重要的知识点"

---

## 简单的javascript拖拽实现

### 实现原理

要实现拖拽其实很简单，无非就是三个事件 mousedown,mousemove,mouseup,基本的思路就是,当mousedown时获取鼠标按下时(down)的位置,和当时元素的位置.当鼠标移动时(move)再次回去鼠标位置,那么移动时元素的位置就应该是：元素开始的位置 + (鼠标移动时的位置 - 鼠标点击时的位置),最后当鼠标松开时,移除移动事件，并最后设置元素位置.根据这一理论,我们先直接简单实现这一效果

```javascript
<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style>
        #drag{
            position: absolute;
            height: 50px;
            width: 50px;
            background-color:#00b7ea;
            border-radius: 1px;
            box-shadow: 0 0 3px rgba(0,0,0,.4);
        }
    </style>
</head>
<body>
<div id="drag"></div>
</body>
<script>
    window.onload = function(){
        var drag = document.getElementById("drag");
        drag.addEventListener('mousedown',function(e){
            //保存当前的this对象的指向，也就是drag元素
            var _this = this;
            e = e || window.event;
            //分别获取鼠标按下时鼠标的位置以及元素的位置
            var startX = e.clientX;
            var startY = e.clientY;
            var startLeft = _this.offsetLeft;
            var startTop = _this.offsetTop;

            //执行mousemove和mouseup事件，为了好移除,这里没有使用匿名函数
            document.addEventListener('mousemove',blockMouseMove,false);
            document.addEventListener('mouseup',blockMouseUp,false);

            function blockMouseMove(e){
                e = e || window.event;
                var moveX = e.clientX;
                var moveY = e.clientY;
                //移动的位置其实 = 鼠标移动的新位置 - 鼠标按下时的位置
                var diffX = moveX - startX;
                var diffY = moveY - startY;
                _this.style.left = startLeft + diffX + "px";
                _this.style.top = startTop + diffY + "px";
            }

            function blockMouseUp(e){
                document.removeEventListener('mousemove',blockMouseMove,false);
                document.removeEventListener('mouseup',blockMouseUp,false);
            }
        },false);
    }
</script>
</html>
```

上面代码关键部分给出了注释,相信大家能够看懂.但是这么简单的实现还有很多问题,比如兼容性,比如重复使用,比如代码的封装等等...要实现这个效果很简单,我们这篇博文主要说的是,怎么样来提取函数,封装我们的代码,一方面让代码整洁一点,看着高大上一下,另一方面,多多练习封装函数,也是提高我们js水平的一个渠道,长期写上面这样的代码,我们的js水平并不能得到多少提高

那么,我们一点一点的来封装

## 封装$()函数

首先,通过id来获取元素这行代码,我们就可以来封装一下,当然,我们可以简单的下面这样封装

```javascript
function $(id){
	return document.getElementById(id);
}
```

相信这个大家都写过,你也可以把这个方法写的更好，甚至于就像jQuery那样也可以,我们这里做一个点稍微复杂一点的封装

```javascript

function $(){
	var elements = [];

	for(var i=0;i<arguments.length;i++){
		var element = arguments[i];

		if(typeof element == "string"){
			element = document.getElementById(element);
		}

		if(arguments.length === 1){
			return element;
		}else{
			elements.push(element);
		}
	}
	return elements;
}

```

上面这种封装看似很难理解,其实很简单,无非就是利用了function的arguments的特性,循环函数中所有的参数,如果传入的是一个字符串,那么直接调用document.getElementById()将元素返回,如果只有一个参数,那么直接返回该元素,否则放入数组中返回,那么这个函数就有了一次传入多个id,并且通过id获取元素,将元素数组返回的能力.

上面这个封装主要用到了3个知识点:
1.函数的参数,arguments
2.typeof 判断数据类型
3.数组元素的添加

## 封装addEvent函数
继续往下用到了addEventListener现代派事件函数,众所周知,现代派事件有兼容性问题,IE用的attachEvent事件监听,而且IE的现代派事件还有个严重问题,就是事件内this指向不正确,所以要使用现代派事件就必须封装才好

```javascript
function addEvent(node,type,listener){
    if(!(node = $(node))) return false;

    if(node.addEventListener){
        node.addEventListener(type,listener,false);
        return true;
    }else if(node.attachEvent){
        node['e' + type + listener] = listener;
        node[type + listener] = function(){
            node['e' + type + listener](window.event);
        }
        node.attachEvent('on'+type,node[type+listener]);
        return true;
    }
    return false;
}
```

这个函数稍微有点复杂,首先是第一句,`if(!(node = $(node))) return false;`,这一句设计有一点巧妙,这么写,首先是防止node并不是一个元素,所以先调用$(node),将值又重新赋给node,这样,一方面可以讲传过来的id转化为一个元素,并且还能确保node就是一个元素.如果不是函数直接返回false退出

下面的判断,W3C的部分没有什么说的,无非就是将值传进去,并且是事件的冒泡,而不是捕获

而IE部分的写法就有点怪异了,其实这么写无非就是为了修复IE现代派事件的BUG,让事件里面的this指向事件发起对象,而不是window.将传入addEvent的参数listener(这个listener本来就是个函数),因为传入的node本身就是一个节点对象，这里相当于给对象创建了一个属性,属性的名字是'e'+type+listener,指向listener函数,而下面的`node[type + listener] = function(){node['e' + type + listener](window.event);}`这一句代码,相当于就是在node元素内执行函数,并且将`window.event`事件对象传入,这样在`node[type + listener]`这个函数内的this指向的就是node对象了,使用闭包的特性达到了改变this指向的效果.

这个封装使用了3个重要知识点:
1.现代派事件的使用
2.this
3.闭包

既然添加事件有了封装，相应的,事件相关的如:移除事件,阻止元素默认事件,阻止冒泡,获取e事件源都可以进行封装,提高兼容性：

```javascript
//移除事件
function removeEvent(node, type, listener) {
	if (!(node = $(node))) {
		return false;
	};

	if (node.removeEventListener) {
		node.removeEventListener(type, listener, false);
		return true;
	} else if (node.detachEvent) {
		node.detachEvent('on' + type, node[type + listener]);
		node[type + listener] = null;
		return true;
	}
	return false;
};

//获取事件对象
function getEventObject(e){
	return e || window.event;
}

//阻止事件冒泡
function stopPropagation(eventObject){
	var eventObject = eventObject || getEventObject();
	if(eventObject.stopPropagation){
		eventObject.stopPropagation();
	}else{
		eventObject.cancelBubble = true;
	}
};

//阻止浏览器默认行为
function stopDefault(eventObject){
	var eventObject = eventObject || getEventObject();
	if(eventObject.preventDefault){
		eventObject.preventDefault();
	}else{
		eventObject.returnValue = false;
	}
	};
```

## 获取鼠标在文档中的位置getPointerPositionInDocument(eventObject)

这个没有什么多说的,当我们使用鼠标事件时,e.clientX,e.pageX,e.offsetX,e.screenX(纵坐标一样)都有不同的含义,而且我们可以直接封装一个函数,让这个函数直接返回鼠标当时的x,y值的坐标对象

```javascript
function getPointerPositionInDocument(eventObject) {
	eventObject = eventObject || getEventObject(eventObject);
	var x = eventObject.pageX || (eventObject.clientX +
		(document.documentElement.scrollLeft || document.body.scrollLeft));
	var y = eventObject.pageY || (eventObject.clientY +
		(document.documentElement.scrollTop || document.body.scrollTop));
	return {
		'x': x,
		'y': y
	};
};
```

PageX:鼠标在页面上的位置,从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化

clientX:鼠标在页面上可视区域的位置,从浏览器可视区域左上角开始,即是以浏览器的可视窗口为参考点,随滑动条移动 而变化

IE中没有PageX，解决办法：

PageY=clientY+scrollTop-clientTop;

页面上的位置=可视区域位置+页面滚动条切去高度-自身border高度
(**注：我写的代码中忽略了border自身高度,所以 -clientTop去掉也可以**)

## 获取元素自身位置及尺寸getDimensions(element)

这个没有什么多解释的,直接看代码:

```javascript
function getDimensions(element){
	if (!(element = $(element))) return false;

	return {
		'left':element.offsetLeft,
		'top':element.offsetTop,
		'width':element.offsetWidth,
		'height':element.offsetHeight
	};
}

```

## 设置元素CSS样式setStyle(element, styles)

设置CSS样式我们一直在使用,每次不过是类似于 `元素节点.style.height="50px"`这种,如果行内样式设置的比较多的话,这样的代码要写很多行,所以,可以将设置CSS样式的代码做一个封装,这里封装了一个setStyle(element, styles)函数,element表示元素节点,styles则是一个对象,需要的CSS属性直接以对象的方式传递进去就行.

当然,既然需要传递CSS样式属性,那么肯定就需要类似于 `font-size,text-align`等这样的字符串,但是这些属性相对于js属性却是 `fontSize,textAlign`等...所以还需要函数进行互相转换

```javascript
    function setStyle(element, styles) {
        if (!(element = $(element))) return false;
        for (property in styles) {
            if (!styles.hasOwnProperty(property)) continue;

            if (element.style.setProperty) {
                element.style.setProperty(
                        uncamelize(property, '-'), styles[property], null);
            } else {
                element.style[camelize(property)] = styles[property];
            }
        }
        return true;
    };

    function camelize(s) {
        return s.replace(/-(\w)/g, function(strMatch, p1) {
            return p1.toUpperCase();
        });
    };

    function uncamelize(s, sep) {
        sep = sep || '-';
        return s.replace(/([a-z])([A-Z])/g, function(strMatch, p1, p2) {
            return p1 + sep + p2.toLowerCase();
        });
    };
```

下面的camelize与uncamelize函数无非就是进行字符串的解析,这段函数在[字符串String](http://www.yingside.com/2015/10/27/js-string)这一节已经讲解过,不清楚的可以点击链接学习。

而setStyle函数中,首先就是通过`for in`循环遍历CSS对象,循环的第一句`if (!styles.hasOwnProperty(property)) continue;` hasOwnProperty是判断对象属性是否是属于对象本身,而属于prototype原型的属性就会被过滤掉.

`setProperty(propertyName,value,priority);`设置属性,并设置是否为`important`,用法:`obj.style.setProperty("color","red","")`,这个写法除了可以设置 `important`之外,与 obj.style.color="red"没有什么区别,只是这是一种DOM的写法,更接近一般语法...但是却有兼容性问题,IE不支持...

这里需要用到的,可以封装的工具方法都差不多了,可以将上面的方法改写:

```javascript
    var moveBlock = $('drag');
    var moveBlockPos = getDimensions(moveBlock);

    addEvent(moveBlock,'mousedown',moveBlockMouseDown);

    function moveBlockMouseDown(e){
        e = getEventObject(e);
        var pointerStart = getPointerPositionInDocument(e);
        var moveBlockStart = getDimensions(moveBlock);

        moveBlock.style.cursor = "move";

        addEvent(document,'mousemove',moveBlockMouseMove);
        addEvent(document,'mouseup',moveBlockMouseUp);

        function moveBlockMouseMove(e){
            e = getEventObject(e);
            var pointer = getPointerPositionInDocument(e)
            var distance = 	getPointerDistance(pointerStart,pointer);

            setStyle(moveBlock,{
                'left':(moveBlockStart.left + distance.x) +"px",
                'top':(moveBlockStart.top + distance.y) +"px",
            });
        }
        function moveBlockMouseUp(e){
            removeEvent(document,'mousemove',moveBlockMouseMove);
            removeEvent(document,'mouseup',moveBlockMouseUp);
        }
    }
    //获取位置差
    function getPointerDistance(pointerStart,pointerEnd){
        return {
            'x':(pointerEnd.x - pointerStart.x),
            'y':(pointerEnd.y - pointerStart.y)
        };
    }

    function $() {
        var elements = new Array();

        for (var i = arguments.length - 1; i >= 0; i--) {
            var element = arguments[i];

            if (typeof element == "string") {
                element = document.getElementById(element);
            }

            if (arguments.length == 1) {
                return element;
            } else {
                elements.push(element);
            }

            return elements;
        };
    };
    //添加事件
    function addEvent(node, type, listener) {
        if (!(node = $(node))) return false;
        if (node.addEventListener) {
            //W3C
            node.addEventListener(type, listener, false);
            return true;
        } else if (node.attachEvent) {
            node['e' + type + listener] = listener;
            node[type + listener] = function() {
                node['e' + type + listener](window.event);
            };
            node.attachEvent('on' + type, node[type + listener]);
            return true;
        }

        return false;

    };

    //移出事件
    function removeEvent(node,type,listener){
        if (!(node = $(node))) return false;
        if(node.removeEventListener){
            node.removeEventListener(type,listener,false);
            return true;
        }else if(node.removeEvent){
            node.detachEvent('on'+type,node[type+listener]);
            node[type+listener] = null;
            return true;
        }
        return false;
    };
    //获取事件对象
    function getEventObject(e){
        return e || window.event;

    }
    //组织事件冒泡
    function stopPropagation(eventObject){
        var eventObject = eventObject || getEventObject();
        if(eventObject.stopPropagation){
            eventObject.stopPropagation();
        }else{
            eventObject.cancelBubble = true;
        }
    };
    //阻止浏览器默认 事件
    function stopDefault(eventObject){
        var eventObject = eventObject || getEventObject();
        if(eventObject.preventDefault){
            eventObject.preventDefault();
        }else{
            eventObject.returnValue = false;
        }
    };
    //获取鼠标位置
    function getPointerPositionInDocument(eventObject) {
        eventObject = eventObject || getEventObject(eventObject);
        var x = eventObject.pageX || (eventObject.clientX +
                (document.documentElement.scrollLeft || document.body.scrollLeft));
        var y = eventObject.pageY || (eventObject.clientY +
                (document.documentElement.scrollTop || document.body.scrollTop));
        return {
            'x': x,
            'y': y
        };
    };
    //获取元素位置和尺寸
    function getDimensions(element){
        if (!(element = $(element))) return false;

        return {
            'left':element.offsetLeft,
            'top':element.offsetTop,
            'width':element.offsetWidth,
            'height':element.offsetHeight
        };
    }
    //设置CSS样式
    function setStyle(element, styles) {
        if (!(element = $(element))) return false;
        for (property in styles) {
            if (!styles.hasOwnProperty(property)) continue;

            if (element.style.setProperty) {
                element.style.setProperty(
                        uncamelize(property, '-'), styles[property], null);
            } else {
                element.style[camelize(property)] = styles[property];
            }
        }
        return true;
    };
    //将CSS样式字符串转化会JS样式 text-align==>textAlign
    function camelize(s) {
        return s.replace(/-(\w)/g, function(strMatch, p1) {
            return p1.toUpperCase();
        });
    };
    //将JS样式字符串转化为CSS样式 fontSize==>font-size
    function uncamelize(s, sep) {
        sep = sep || '-';
        return s.replace(/([a-z])([A-Z])/g, function(strMatch, p1, p2) {
            return p1 + sep + p2.toLowerCase();
        });
    };

```

当然这么看代码增加了...只是我们还没有进行进一步的封装,我们可以将这些工具方法,直接再封装起来,这样就可以形成我们自己的一个类似于jQuery一样的js库了...这个我们在后续章节中再进行封装


